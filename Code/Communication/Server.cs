#define SAVE_JSON_TEXT_TO_CACHE // can be useful to disable this locally for perf testing (note this is Editor-only)

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using Com.HitItRich.Feature.TimedBonus;
using Com.HitItRich.Feature.VirtualPets;
using Com.Scheduler;
using Zynga.Zdk;

using Ionic.Zlib;
using Zynga.Core.Util;
using UnityEngine.Networking;

/**
Functions for communicating with the backend server and parsing the response data.
*/
public class Server : IResetGame
{
	public const float  RETRY_DELAY_TIME = 10f;                 // Seconds between post retry attempts
	public const int    MAX_POST_ATTEMPTS = 3;                  // The maximum number of retries before aborting and forcing a client refresh.
	public const int    USE_COMPRESSION_BYTE_THRESHOLD = 128;   // Use compression for action batches larger than this (in bytes)
	public const string ACTION_RESPONSE_KEY = "postActions";    // Key to identify a post actions response
	public const float  MAX_DOWNLOAD_ATTEMPT_TIME = 45f;        // Seconds to attempt request.
	public const float RESPONSE_TIMEOUT_INTERVAL = 10000;

	private const int   MAX_SPLUNK_LOG_FIELDS = 30;             // Max number of fields server accepts for each splunk log event
	private const int   MAX_SPLUNK_QUEUE_SIZE = 100;            // Max splunk events before flushing a batch flush (0=no batching)
	private const int   MAX_SPLUNK_IDLE_IN_SEC = 30;            // Max splunk idle time before flushing a batch

	/// Returns true if a post has been made and a response still hasn't come back.
	/// We occasionally need to put debug logs in the getter, so please leave this as is.
	public static bool waitingForActionsResponse
	{
		get
		{
			return _waitingForActionsResponse;
		}
		
		private set
		{
			_waitingForActionsResponse = value;
		}
	}
	private static bool _waitingForActionsResponse = false;

	public static long shouldHaveCredits = -1L;
	public static string stringShouldHaveCredits = "";

	// Used to keep track of all the total pending credits so we don't need to 
	// iterate through the dictionary and add everything up.
	public static long totalPendingCredits => pendingCreditsDict.Values.Sum();

	// If we have features that have their coins granted strictly on the server side, when we get a message stating that we've
	// recieved coins, add the feature that got the message here with the amount given. That way if we spin prior to processing the
	// message, we can log what feature is slow to load/slow to process.
	public static Dictionary<string, long> pendingCreditsDict = new Dictionary<string, long>();

	public static ConnectionLevel connectionLevel = ConnectionLevel.UNKNOWN;

	public static List<WWW> pendingLogWWWs = new List<WWW>();		// A list of log WWWs to prevent cleanup before transmission

	public static List<JSON> actionEvents = new List<JSON>();       // A list of unhandled server events that are waiting to be handled
	public static Dictionary<string, List<JSON>> lostAndFoundEvents = new Dictionary<string, List<JSON>>(); // A list of unhandled server events that did not have handlers

	public static List<JSON> multipleEvents = new List<JSON>(); 	// A dictionary of multiple same type unhandled events 

	private static Dictionary<string, JSON> responses = new Dictionary<string, JSON>();	// A dictionary of recent responses

	private static GameTimer pendingResponseTimer = new GameTimer(RESPONSE_TIMEOUT_INTERVAL); // A Timer for response processing timeout

	private static Dictionary<string, EventDelegate> eventCallbacksOneShot = new Dictionary<string, EventDelegate>();
	private static Dictionary<string, EventDelegate> eventCallbacksPersistent = new Dictionary<string, EventDelegate>();
	private static Dictionary<string, EventGroupDelegate> eventGroupCallbacks = new Dictionary<string, EventGroupDelegate>();

	private class EventCallbackData
	{
		public EventDelegateWithParam callback;
		public System.Object callbackParameter;
		public bool isPersistent;
	}
	private static Dictionary<string, EventCallbackData> eventCallbacksWithParam = new Dictionary<string, EventCallbackData>();

	private const string SALT = "NpHM8ti315$j!9r";		// Our server-agreed-upon salt for hash-signing requests
	public static string accessKey = "";				// Our server-provided session access key

	/// These are generated by makeErrorBaseStrings() and should not be edited
	private static string errorBaseCompiled = "{{\"message\":\"{0}\",\"stack_trace\":\"{1}\",\"extra_info\":\"{2}\"}}";
	private static string errorBaseExtraInfo;
	
	// Debug value to store the server-based client version error message.
	private static string recentServerErrorMessage = "";
	private static string recentHttpErrorMessage = "";
	
	// Get a string representing a recent encountered http request error.
	public static string recentErrorMessage
	{
		get
		{
			if (!string.IsNullOrEmpty(recentHttpErrorMessage))
			{
				return recentHttpErrorMessage;
			}
			else if (!string.IsNullOrEmpty(recentServerErrorMessage))
			{
				return recentServerErrorMessage;
			}
			
			// This is intentionally misleading because it is customer facing,
			// but we know that it means we have no idea what is wrong.
			return "Unable to connect.";
		}
	}

	// For batching of splunk info logs
	private static List<object> splunkEventQueue = new List<object>(MAX_SPLUNK_QUEUE_SIZE);
	private static GameTimer splunkEventTimer = new GameTimer(0);

	// Returns all available full URLs to a static data request.
	public static string[] findAllStaticUrls(string path)
	{
		if (Glb.staticAssetHosts != null && Glb.staticAssetHosts.Length > 1)
		{
			Queue<string> urlsList = new Queue<string>();
			string defaultHost = "";
			
			// Scan for a matching default url in the base path
			foreach (string host in Glb.staticAssetHosts)
			{
				if (!string.IsNullOrEmpty(host) && path.Contains(host))
				{
					defaultHost = host;
					break;
				}
			}
			
			// Replace that start url with each alternative
			if (!string.IsNullOrEmpty(defaultHost))
			{
				foreach (string host in Glb.staticAssetHosts)
				{
					if (!string.IsNullOrEmpty(host))
					{
						urlsList.Enqueue(path.Replace(defaultHost, host));
					}
				}
			}
			
			// We only bother with this if there are actual options
			if (urlsList.Count > 1)
			{
				return urlsList.ToArray();
			}
		}
		
		// Fallback to just returning a list that contains the original path
		return new string[] { path };
	}

	/// Turns a utf8 string to base64.
	public static string toBase64(string s)
	{
	   byte[] data = System.Text.Encoding.UTF8.GetBytes(s);
	   return System.Convert.ToBase64String(data);
	}

	/// Turns a base64 string to utf8.
	public static string fromBase64(string s)
	{
	   byte[] data = System.Convert.FromBase64String(s);
	   return System.Text.Encoding.UTF8.GetString(data);
	}

	/// Checks a string response and decompresses it if needed.
	public static string decompressResponse(string response)
	{
		if (response == null || response.Length == 0)
		{
			Debug.LogError("Null server response.");
			return "";
		}

		// see relevant server function compress_response() here:
		// https://github-ca.corp.zynga.com/HitItRich/casino_server/blob/60526cb19f72ab1332fb6ab972ed5f61726feb57/public/common/global_helpers.php
		if (response[0] == 'c')
		{
			// response was 'compressed' by server
			try
			{
				string s = response.Substring(1);   // need to copy the whole buffer to advance 1 char, ugh

				// for compressed-json-msgs, server sends a base64-encoded zlib-deflated stream (i.e. gzip w/o the gzip header)
				// with a 'c' prepended to indicate compression.
				/// TODO: Server SHOULD use HTTP "Content-Type: deflate" instead of requiring base64 conversion and
				///       prepending 'c' to indicate compression. 
				///       This would reduce the number of buffer allocations and unnecessary bytes->text->bytes conversions we need to make.

				byte[] deflated_bytes = System.Convert.FromBase64String(s);

				// server is sending us a Deflated stream (i.e. Gzip without gzip header)
				byte[] text_bytes = DeflateStream.UncompressBuffer(deflated_bytes);
				return System.Text.Encoding.UTF8.GetString(text_bytes);
			}
			catch (System.Exception ex)
			{
				Debug.LogError("Invalid deflated stream from server: " + ex.ToString());
				return "";
			}
		}
			
		// process as if a json text response
		string textResponse = response.Trim();
		if (textResponse[0] == '{')  // we only handle JSON-format responses now!
		{
			return textResponse;
		}
		Debug.LogErrorFormat("Unrecognized server response data: {0}", textResponse);
		return "";
	}

	public static byte [] decompressGzipResponse(byte [] zipfile_stream)
	{
		try
		{
			byte [] uncompressed_bytes = GZipStream.UncompressBuffer(zipfile_stream);
			return uncompressed_bytes;
		}
		catch (System.Exception ex)
		{
			Debug.LogErrorFormat("Invalid gzip stream from server: {0}", ex.ToString());
			return null;
		}
	}

	/// Compresses a string as a base64 deflate stream, which is what server wants
	/// TODO: Server SHOULD use HTTP content-type header instead of requiring base64 conversion and
	///       prepending 'c' to indicate compression.  This would reduce the number of buffer allocations we need to make.
	public static string compressString(string s)
	{
		byte[] stringBytes = System.Text.Encoding.UTF8.GetBytes(s);
		byte[] deflated_bytes = DeflateStream.CompressBuffer(stringBytes);
		return System.Convert.ToBase64String(deflated_bytes);
	}

	/// Creates a HTTP POST connection.
	public static WWW getRequestWWW(string url, Dictionary<string, string> elements = null)
	{
		bool useOptionalLog = Data.debugMode && (PlayerPrefsCache.GetInt(DebugPrefs.OPTIONAL_LOGS, 0) != 0);

		if (elements == null)
		{
			if (useOptionalLog)
			{
				Glb.editorLog("GET:", url);
			}
			
			return new WWW(url);
		}
		else
		{
			WWWForm form = createFormForPOST(url, useOptionalLog, elements);
			return new WWW(url, form);
		}
	}
	
	public static UnityWebRequest getRequestUWR(string url, Dictionary<string, string> elements = null)
	{
		bool useOptionalLog = Data.debugMode && (PlayerPrefsCache.GetInt(DebugPrefs.OPTIONAL_LOGS, 0) != 0);

		if (elements == null)
		{
			if (useOptionalLog)
			{
				Glb.editorLog("GET:", url);
			}
			
			return UnityWebRequest.Get(url);
		}
		else
		{

			WWWForm form = createFormForPOST(url, useOptionalLog, elements);
			return UnityWebRequest.Post(url, form);
		}
	}

	private static WWWForm createFormForPOST(string url, bool useOptionalLog, Dictionary<string, string> elements)
	{
		WWWForm form = new WWWForm();

		System.Text.StringBuilder toHash = new System.Text.StringBuilder();
		System.Text.StringBuilder displayData;

		if (useOptionalLog)
		{
			displayData = new System.Text.StringBuilder();
		}
		else
		{
			displayData = null;
		}

		// Include in the sku_id
		elements["sku_id"] = SkuResources.skuString;
		elements["sku_key"] = SkuResources.skuString;
			
		// Include a random parameter for hashing
		elements["r"] = UnityEngine.Random.Range(0, 1000000).ToString();
			
		List<string> elementsSorted = new List<string>(elements.Keys);
		elementsSorted.Sort();

		string value;
		string lowerKey;
		bool first = true;
		foreach (string key in elementsSorted)
		{
			if (elements.ContainsKey(key))
			{
				value = elements[key];
			} else {
				value = "";
			}
			lowerKey = key.ToLower();

			if (first)
			{
				first = false;
			}
			else
			{
				toHash.Append(SALT);
			}
			toHash.Append(value);

			form.AddField(lowerKey, value);

			if (useOptionalLog)
			{
				displayData.Append(lowerKey);
				displayData.Append("=");
				displayData.Append(value);
				displayData.Append(" ");
			}
		}
		string hash = "";
		if (toHash.Length > 0)
		{
			hash = MD5Encode.encode(toHash.ToString());
		}
		form.AddField("h", hash);

		if (useOptionalLog)
		{
			displayData.Append("h=");
			displayData.Append(hash);
			Glb.editorLog("POST:", url, "DATA:", displayData.ToString());
		}

		return form;
	}

	// incremental counter for each request (for logging purposes)
	private static int reqCount = 0;
	
	/// Attempt to get some data, retry as needed, and when failing reload the client
	public static IEnumerator attemptRequest(string requestUrl, Dictionary<string, string> elements, string defaultErrorKey, 
											 string responseKey, bool forceGameRefreshOnFail = true, string cacheFileName = "", 
											 bool shouldLoadCached = true)
	{
		// check timer status
		if(pendingResponseTimer.isExpired)
		{
			onTimeout();
		}
		// for logging purposes
		reqCount++;
		string REQ = string.Format("Req{0}_",reqCount);

		// json caching behavior/format from LiveData JSON_CACHING var:  -1=no caching, 0=text, 1=UTF8Binary, 2=UnicodeBinary
		// ("1" seems to be the default value currently)
		string desiredCacheFormat = Glb.JSON_CACHE_FORMAT;
		
		// Simple sanity check that the url probably has a protocol
		if (!requestUrl.Contains("://"))
		{
			requestUrl = Glb.urlPrefix + requestUrl;
		}

		// Safety check for cache-enabled devices (important for a rare case on Android)
		if (string.IsNullOrEmpty(FileCache.path))
		{
			// Since the cache space is unavailable, just disable caching and download fresh
			cacheFileName = "";
			shouldLoadCached = false;
		}

		string cacheBasePath =  FileCache.path + cacheFileName;
		string versionPath = cacheBasePath + ".version";
		string dataPath = cacheBasePath + ".data";

		bool isCompressedBinaryJsonFile = requestUrl.Contains(".jsonb.gz");
		
		// Process cached response?
		if (!string.IsNullOrEmpty(cacheFileName) && shouldLoadCached)
		{
			// Response caching consists of two files, one that tracks/validates the version and the other that actually stores the data.
			// Read cached request data and version info.

			if (File.Exists(versionPath) && File.Exists(dataPath))
			{
				// It's sloppy, but a generic try-catch here makes life easier, as almost every line below can throw an exception.
				try
				{
					string versionText = File.ReadAllText(versionPath, System.Text.Encoding.UTF8);
					string[] versionParts = versionText.Split('\n');
					string versionUrl = versionParts[0];
					string versionHash = versionParts[1];
					string versionCacheFormat = versionParts.Length > 2 ? versionParts[2] : "0"; //use "0" (text) if nothing specified

					if (versionUrl == requestUrl && versionCacheFormat == desiredCacheFormat)
					{
						if (versionCacheFormat == "0")
						{
							StatsManager.Instance.LogLoadTimeStart(REQ+"LoadTCache");
							string responseText = File.ReadAllText(dataPath, System.Text.Encoding.UTF8);
							StatsManager.Instance.LogLoadTimeEnd(REQ+"LoadTCache");
							
							StatsManager.Instance.LogLoadTimeStart(REQ+"MD5LTCache");						
							string responseHash = MD5Encode.encode(CommonText.stringCombine(responseText, requestUrl, SALT));
							StatsManager.Instance.LogLoadTimeEnd(REQ+"MD5LTCache");
							
							if ((responseHash == versionHash) && ((responseText[0]=='{') || (responseText[0]=='[')))
							{
								StatsManager.Instance.LogLoadTimeStart(REQ+"JsonifyLTCache");
								JSON responseData = new JSON(responseText);
								StatsManager.Instance.LogLoadTimeEnd(REQ+"JsonifyLTCache");
								
								if (responseData.isValid)
								{
									setResponseData(responseKey, responseData);
									yield break;
								}
							}
						}
						else if (versionCacheFormat == "1" || versionCacheFormat == "2")
						{
							string statKey = REQ+"LoadBCache";
							StatsManager.Instance.LogLoadTimeStart(statKey);
							var bytes = File.ReadAllBytes(dataPath);
							StatsManager.Instance.LogLoadTimeEnd(statKey);

							statKey = REQ+"MD5LBCache";
							StatsManager.Instance.LogLoadTimeStart(statKey);
							string responseHash = MD5Encode.encode(bytes); // MD5 for now...
							StatsManager.Instance.LogLoadTimeEnd(statKey);
							
							if (responseHash == versionHash)
							{
								statKey = REQ+"JsonifyLBCache";
								StatsManager.Instance.LogLoadTimeStart(statKey);
								JSON responseData = new JSON(bytes);
								StatsManager.Instance.LogLoadTimeEnd(statKey);
								
								if (responseData.isValid)
								{
									setResponseData(responseKey, responseData);
									yield break;  // found the response in cache, so return immediately
								}
							}

						}
					}
				}
				catch(System.Exception e)
				{
					Debug.LogWarning("Failed reading cache for " + requestUrl + "  Error: " + e.Message);
				}

				// If we get to this code, then the cached data is corrupt somehow, so purge it.
				try
				{
					File.Delete(dataPath);
				}
				catch
				{
				}
				
				try
				{
					File.Delete(versionPath);
				}
				catch
				{
				}
			}
		}

		JSON response = null;

		string userErrorKey = "";
		string errorText = "";
		string failAction = "retry";
		string systemErrorMessage = "Unknown transmission error.";
		
		// If there are valid alternative urls, make sure we can use them.
		// This will populate with a single entry if this isn't a static akamai url.
		string[] requestUrls = findAllStaticUrls(requestUrl);
		int currentRequestUrlIndex = 0;
		float totalAttemptTime = 0;

		// Attempt to get a valid response several times.
		int attempts = 0;
		while (response == null)
		{
			attempts++;
			if (attempts > MAX_POST_ATTEMPTS || totalAttemptTime > MAX_DOWNLOAD_ATTEMPT_TIME)
			{
				if (systemErrorMessage == "")
				{
					systemErrorMessage = "Transmission fail: reached maximum retries.";
				}
				response = null;
				break;
			}

			// After the first attempt wait a little bit before retrying
			if (attempts > 1)
			{
				totalAttemptTime += RETRY_DELAY_TIME;
				yield return new WaitForSeconds(RETRY_DELAY_TIME);
			}

			float downloadTime = Time.realtimeSinceStartup;
			string currentRequestUrl = requestUrls[currentRequestUrlIndex];
			currentRequestUrlIndex = (currentRequestUrlIndex + 1) % requestUrls.Length;
			
			// DO NOT ECHO THE REQUEST OR RESPONSE TO ANY LOG, USE THE EXISTING FUNCTIONALITY IN GAME LOGIN SETTINGS
			// IF YOU NEED TO DO IT YOURSELF TO BELIEVE THE RESULTS, THEN PLEASE DO NOT COMMIT YOUR CHANGE!
			StatsManager.Instance.LogLoadTimeStart(REQ+"WWWReq");
			byte[] responseBinaryJsonData = null;  // used if request is for a compressed binary json file .jsonb.gz
			string responseData = "";
			using (UnityWebRequest uwr = getRequestUWR(currentRequestUrl, elements))
			{
				yield return uwr.SendWebRequest();
							
				StatsManager.Instance.LogLoadTimeEnd(REQ+"WWWReq");
						
				downloadTime = Time.realtimeSinceStartup - downloadTime;
				totalAttemptTime += downloadTime;



				if (string.IsNullOrEmpty(uwr.error))
				{
					int dataSize;
					string decompStatKey = REQ + "Decomp";
					StatsManager.Instance.LogLoadTimeStart(decompStatKey);
					if (isCompressedBinaryJsonFile)
					{
						// cant use decompressResponse because this isnt a normal 'compressed'
						// response that has 'c' prepended to base64-encoded text data (which is an ugly way to do it, should use http-content-type header instead,
						// so we can skip the base64-stuff entirely)
						byte[] data = uwr.downloadHandler.data;
						dataSize = data.Length;
						// instead this is a gzipped file
						responseBinaryJsonData = decompressGzipResponse(data);
					}
					else
					{
						string data = uwr.downloadHandler.text;
						dataSize = data.Length;
						responseData = decompressResponse(data);
					}
					StatsManager.Instance.LogLoadTimeEnd(decompStatKey);
					adjustConnectionSpeed(dataSize, downloadTime);
					// Reset this error string
					recentHttpErrorMessage = "";
				}
				else
				{
					systemErrorMessage = uwr.error;
					recentHttpErrorMessage = uwr.error;
				}
			}


			// These WILL slow down the game and bog up our servers - only enabled in debug builds.
			if (Data.debugMode)
			{
				string responseLog = "RECEIVED: " + responseData;
				Glb.editorLog(responseLog);
			}
#if ZYNGA_TRAMP
			if (AutomatedPlayer.instance != null && AutomatedPlayer.isAutomating)
			{
				AutomatedPlayer.instance.recieved(responseData);
			}
#endif // ZYNGA_TRAMP

#if !ZYNGA_PRODUCTION
			DesyncAction.receiveServerOutcomes(responseData);
#endif

			if (string.IsNullOrEmpty(responseData) && (responseBinaryJsonData==null))
			{
				// Begin with checking the response data to see if it is null or empty.
				// Note: JSON parsing errors will be caught later on.
				if (systemErrorMessage == "")
				{
					systemErrorMessage = "Transmission fail: unable to decompress data.";
				}
				Debug.LogErrorFormat("SystemErrorMessage: {0} - for URL: {1} -- downloadTime: {2}\n[Attempt {3}] Server data unrecognized!",systemErrorMessage,currentRequestUrl,downloadTime,attempts);
			}
			else
			{
				// Try to get some JSON out of the response data
				string jsonifyKey = REQ+"Jsonify";
				StatsManager.Instance.LogLoadTimeStart(jsonifyKey);	

				if (responseBinaryJsonData != null)
				{
					response = new JSON(responseBinaryJsonData);    // this will use JsonBinaryReader to read our custom fmt
				}
				else
				{
					response = new JSON(responseData);
				}
				StatsManager.Instance.LogLoadTimeEnd(jsonifyKey);

				// Response checking
				if (response == null || !response.isValid)
				{
					// Something went terribly wrong!

					systemErrorMessage = "Transmission fail: could not parse JSON.";
					response = null;
				}
				else if (response.hasKey("error"))
				{
					// These is a specific server error response.

					errorText = response.getString("error.message", "No server message given for error block.");
					failAction = response.getString("error.response", "retry");
					userErrorKey = response.getString("error.message_key", "");
					recentServerErrorMessage = errorText;

					Debug.LogWarning(string.Format("[Attempt {0}] Server error returned! {1} for request {2}", attempts, errorText, currentRequestUrl));

					response = null;
					
					if (failAction != "retry")
					{
						systemErrorMessage = "";
						break;
					}
				}
				else
				{
					// The data is received and assumed good.

					// Cache the response to a local file to reload later?
					if (!string.IsNullOrEmpty(cacheFileName) && shouldLoadCached)
					{
						// Response caching consists of two files, one that tracks/validates the version and the other that actually stores the data.
						// Write cached request data and version info.

						// It's sloppy, but a generic try-catch here makes life easier, as almost every line below can throw an exception.
						try
						{
							if (desiredCacheFormat == "0")
							{
								StatsManager.Instance.LogLoadTimeStart(REQ + "MD5STCache");
								string dataText = responseData;
								string dataHash = MD5Encode.encode(CommonText.stringCombine(dataText, requestUrl, SALT));
								string versionText = string.Format("{0}\n{1}\n{2}", requestUrl, dataHash, desiredCacheFormat);
								StatsManager.Instance.LogLoadTimeEnd(REQ + "MD5STCache");
								
								StatsManager.Instance.LogLoadTimeStart(REQ + "SaveTCache");
								File.WriteAllText(versionPath, versionText, System.Text.Encoding.UTF8);
								File.WriteAllText(dataPath, dataText, System.Text.Encoding.UTF8);
								StatsManager.Instance.LogLoadTimeEnd(REQ + "SaveTCache");							
								//Debug.Log("Wrote cached response to " + dataPath);
							}
							else if (desiredCacheFormat == "1" || desiredCacheFormat == "2")
							{
								byte[] bytes = null;

								if (responseBinaryJsonData!=null)
								{
									// data is already in JSON-binary format, so just write it out
									bytes = responseBinaryJsonData;
									desiredCacheFormat = "1";  // offline jsonToBinary tool always uses JSON.Format.UTF8  
								}
								else
								{
									//Convert json to binary
									StatsManager.Instance.LogLoadTimeStart(REQ + "ToBin");
									bytes = response.toBinary(
														desiredCacheFormat == "1" ? JSON.Format.UTF8 : JSON.Format.UNICODE,
														requestUrl); 
									StatsManager.Instance.LogLoadTimeEnd(REQ + "ToBin");
								}
								
								// create md5 hash
								StatsManager.Instance.LogLoadTimeStart(REQ + "MD5SBCache");
								string md5Hash = MD5Encode.encode(bytes);
								StatsManager.Instance.LogLoadTimeEnd(REQ + "MD5SBCache");
								
								StatsManager.Instance.LogLoadTimeStart(REQ + "SaveBCache");
								string versionText = string.Format("{0}\n{1}\n{2}", requestUrl, md5Hash, desiredCacheFormat);
								File.WriteAllText(versionPath, versionText, System.Text.Encoding.UTF8);
								File.WriteAllBytes(dataPath, bytes);
								StatsManager.Instance.LogLoadTimeEnd(REQ + "SaveBCache");		
								
#if UNITY_EDITOR
								{
									// Sanity test - validate the encoded+decoded binary json against the original json
									// This is expensive at load time for the editor, so only validate if you need to.
									//var jsonFromBin = new JSON(bytes);
									//var jsonTextFromBin = JSON.createJsonString(null, jsonFromBin);
									//var jsonTextFromOrigJson = JSON.createJsonString(null, response);

									//if (jsonTextFromBin != jsonTextFromOrigJson)
									//{
									//	throw new System.Exception("Binary JSON Cache validation failed!");
									//}
								}
#endif
							}
						}
						catch (System.Exception e)
						{
							Debug.LogWarning("Failed writing cache for " + requestUrl + "  Format: " + desiredCacheFormat + "  Error: " + e.Message);
						}						
					}

#if (UNITY_EDITOR && SAVE_JSON_TEXT_TO_CACHE)
					// When in-editor (and not profiling), save a textual copy of the JSON as a convenience to devs...
					if (!string.IsNullOrEmpty(cacheFileName) && !UnityEngine.Profiling.Profiler.enabled)
					{
						// Write the raw json text to a file (if json came from a binary source, we deserialize it)
						string jsonText = (responseBinaryJsonData!=null) ? response.ToString() : responseData;
						File.WriteAllText(cacheBasePath+"(raw).txt", jsonText);

						// Write prettified json text to a file (via Zynga.Core.JsonUtil)
						var prettyJsonText = Zynga.Core.JsonUtil.Json.SerializeHumanReadable(response.jsonDict);
						File.WriteAllText(cacheBasePath + "(pretty).txt", prettyJsonText);
					}
#endif

				}
			}
		}

		// If we totally failed, refresh the client
		if (response == null && forceGameRefreshOnFail)
		{
			if (string.IsNullOrEmpty(userErrorKey))
			{
				if (string.IsNullOrEmpty(systemErrorMessage))
				{
					forceGameRefresh("Unknown", defaultErrorKey, true);
				}
				else
				{
					forceGameRefresh(systemErrorMessage, "", true);
				}
			}
			else
			{
				forceGameRefresh(userErrorKey, userErrorKey, false);
			}
		}

		setResponseData(responseKey, response);
	}

	private static void adjustConnectionSpeed(int dataLength, float downloadTime)
	{
		// If we have a decent amount of data in a logical amount of time, recalculate connectionLevel
		if (dataLength > 5000 && downloadTime > 0.01f)
		{
			float speedFactor = ((float)dataLength) / downloadTime;
			if (speedFactor < 300000f)
			{
				connectionLevel = ConnectionLevel.SLOW;
			}
			else if (speedFactor < 600000f)
			{
				connectionLevel = ConnectionLevel.AVERAGE;
			}
			else
			{
				connectionLevel = ConnectionLevel.FAST;
			}
		}
	}

	/// Sets a server response for later retrieval
	public static void setResponseData(string responseKey, JSON response)
	{
		// Note: this will overwrite any existing value for responseKey
		responses[responseKey] = response;
	}

	/// Gets a server response and clears it from the response cache
	public static JSON getResponseData(string responseKey, bool removeFromCache = true)
	{
		JSON response; 
		if (responses.TryGetValue(responseKey, out response))
		{
			if (removeFromCache)
			{
				responses.Remove(responseKey);
				if(responses.Count == 0)
				{
					pendingResponseTimer = new GameTimer(RESPONSE_TIMEOUT_INTERVAL);
				}
			}

			return response;
		}
		return null;
	}

	/// Gathers up elements for an action batch
	public static Dictionary<string, string> collectActionElements(string json, bool allowConsole = true)
	{
		// If there is missing information here, then we are in a critical situation and should bail.
		if (SlotsPlayer.instance == null)
		{
			Debug.LogWarning("Server.collectActionElements() missing SlotsPlayer.instance");
			return null;
		}
		else if (SlotsPlayer.instance.socialMember == null)
		{
			Debug.LogWarning("Server.collectActionElements() missing SlotsPlayer.instance.socialMember");
			return null;
		}
		else if (ZdkManager.Instance == null)
		{
			Debug.LogWarning("Server.collectActionElements() missing ZdkManager.Instance");
			return null;
		}
		else if (ZdkManager.Instance.Zsession == null)
		{
			Debug.LogWarning("Server.collectActionElements() missing ZdkManager.Instance.Zsession");
			return null;
		}
		
		// Build the POST form.
		Dictionary<string, string> elements = new Dictionary<string, string>();
		PreferencesBase UnityPrefs = SlotsPlayer.getPreferences();
		string batchFormat;

		if (json.Length > USE_COMPRESSION_BYTE_THRESHOLD)
		{
			elements.Add("batch", compressString(json));
			elements.Add("c", "1");
			batchFormat = "gzip";
		}
		else
		{
			elements.Add("batch", json);
			batchFormat = "raw";
		}

		bool serverDebugging = (UnityPrefs.GetInt(DebugPrefs.SERVER_DEBUGGING, 0) != 0);
		if (serverDebugging)
		{
			elements.Add("debug", "1");
		}

		elements.Add("cr", "1");

		elements.Add("sc_id",		SlotsPlayer.instance.socialMember.zId);
		elements.Add("access_key",	accessKey);
		
		// Get the zid that same way that we do for login
		string zid = ZdkManager.Instance.Zsession.Zid + "";
		if (!string.IsNullOrEmpty(Data.overrideZid) && Data.overrideZid != "none")
		{
			zid = Data.overrideZid;
		}
		
		elements.Add("zid",	zid);
		elements.Add("sn_id", (int)ZdkManager.Instance.Zsession.Snid + "");
		elements.Add("client_id", (int)ZyngaConstants.ClientId + "");
		elements.Add("client_build", Glb.clientVersion);
		elements.Add("data_version", SlotGameData.dataVersion);
		//Adding zis token as it is required by the server
		if (PackageProvider.Instance.Authentication.Flow != null && PackageProvider.Instance.Authentication.Flow.Account != null)
		{
			elements.Add("zis_token", PackageProvider.Instance.Authentication.Flow.Account.ZisToken.Token);
		}

		// If the player already has and a fb auth token pass it up to the backend, if the user is logging in non-anonymously.
		// This is most relavent to the mobile build but could come in handy for the editor also.  However, we don't want to send this up to the server 
		// while anonymous, because it makes the server search for an fbid and causes problems with experiments.
		string authToken = ZdkManager.Instance.Zsession.Token;
		//if (!string.IsNullOrEmpty(authToken) && (UnityPrefs.GetInt(SocialManager.kFacebookLoginSaved,0) == 1 || UnityPrefs.GetInt(SocialManager.kLoginPreference,0) == 3))
		if (SlotsPlayer.isFacebookUser)
		{
			if (SlotsPlayer.getPreferences().HasKey(SocialManager.fbToken))
			{
				authToken = SlotsPlayer.getPreferences().GetString(SocialManager.fbToken);
			}
			elements.Add("fb_token", authToken);
		}

		if (PackageProvider.Instance.Track.Service != null)
		{
			long? appLoadId = PackageProvider.Instance.Track.Service.CurrentAppLoadId;
			if (appLoadId.HasValue)
			{
				elements.Add("app_load_id", appLoadId.Value.ToString());
			}
		}

		// These WILL slow down the game - only enabled in debug builds.
		if (Data.debugMode && allowConsole)
		{
			Glb.editorLog("[" + batchFormat + "] BATCH:", json);
		}
#if ZYNGA_TRAMP
		if (AutomatedPlayer.instance != null && AutomatedPlayer.isAutomating)
		{
			AutomatedPlayer.instance.post(json.ToString());
		}
#endif // ZYNGA_TRAMP

		return elements;
	}

#if !ZYNGA_PRODUCTION
	private static void readFakeMessageQueue(bool sendToLostAndFound)
	{
		PreferencesBase prefs = SlotsPlayer.getPreferences();
		string messages = prefs.GetString(DebugPrefs.FAKE_SERVER_EVENT_QUEUE, "");
		
		if (!string.IsNullOrEmpty(messages))
		{
			JSON root = new JSON(messages);
			if (root != null)
			{
				queueJSONMessages(root.getJsonArray("events"), sendToLostAndFound);
			}
		}

		//clear these now that they've been read
		prefs.SetString(DebugPrefs.FAKE_SERVER_EVENT_QUEUE, "");
		prefs.Save();
	}
#endif
	
	public static void queueJSONMessages(IEnumerable<JSON> messages, bool sendToLostAndFound)
	{
		// Append new events to the list of any old events
		foreach (JSON newEvent in messages)
		{
			string key = newEvent.getString("type", "none");
			if (sendToLostAndFound)
			{
				List<JSON> events = null;
				if (!lostAndFoundEvents.TryGetValue(key, out events))
				{
					events = new List<JSON>();
					lostAndFoundEvents[key] = events;
				}

				events.Add(newEvent);
			}
			else
			{
				actionEvents.Add(newEvent);	
			}
#if !ZYNGA_PRODUCTION
			ActionHistory.addRecievedEvent(key, newEvent);
#endif
		}
	}

	/// Posts all actions currently in the action queue to the server,
	/// and processes the responses.
	public static IEnumerator postActions(string json)
	{
		Dictionary<string, string> elements = collectActionElements(json);
		if (elements == null)
		{
			// Error should already be logged, so just bail
			Debug.LogError("Server.postActions() failed to collect action elements.");
			waitingForActionsResponse = false;
			yield break;
		}
				
		waitingForActionsResponse = true;

		yield return RoutineRunner.instance.StartCoroutine(attemptRequest(Glb.actionUrl, elements, "error_failed_to_send_actions", ACTION_RESPONSE_KEY));

		if (!SlotsPlayer.isLoggedIn)
		{
			// If the player logged out while waiting for the action response, don't do anything with the response.
			waitingForActionsResponse = false;
			yield break;
		}

		JSON response = Server.getResponseData(ACTION_RESPONSE_KEY);
		
		if (response == null)
		{
			Debug.LogWarning("Server response error was encountered with action batch, there should be some earlier error logged.");
			waitingForActionsResponse = false;
			yield break;
		}

		if (Data.debugMode)
		{
			Debug.LogFormat("PN> Server postActions responds: {0}\n{1}", response.ToString(), getInfoString());
		}

		// Grab the sanity value for what credits should be
		if (response.hasKey("ending_credits"))
		{
			shouldHaveCredits = response.getLong("ending_credits", 0);
			stringShouldHaveCredits = response.getString("ending_credits", "0");
			PlayerResource.logServerCredits(shouldHaveCredits);
		}

		if (response.hasKey("server_epoch_time"))
		{
			GameTimer.updateServerEpochTime(response);
		}

		// Append new events to the list of any old events
		queueJSONMessages(response.getJsonArray("events"), false);
		
		//process queue
		handleActionEventQueue(true);
		
		// Save any remaining unhandled events for next round
		actionEvents.Clear();
		waitingForActionsResponse = false;
	}

	private static void handleActionEventQueue(bool addToLostAndFound = false)
	{
		// Prepare to store group callback data.
		Dictionary<EventGroupDelegate, Dictionary<string, JSON>> groupCallbackData = new Dictionary<EventGroupDelegate, Dictionary<string, JSON>>();
		// Handle the action events.
		foreach (JSON actionEvent in actionEvents)
		{
			string eventType = actionEvent.getString("type", "");

			//Hack to fix multiple events in the queue for watch to earn
			if (eventType == "w2e_reward_grant")
			{
				multipleEvents.Add(actionEvent);
			} 

			// First check the one-shot event delegate registrations.
			if (!checkEventCallbacks(actionEvent, eventType, eventCallbacksOneShot, doUnregister:true))
			{
				// If no one-shot registration was found, try the persistent ones.
				if (!checkEventCallbacks(actionEvent, eventType, eventCallbacksPersistent, doUnregister:false))
				{
					// check if event is type that takes a parameter
					if (!checkEventCallbacks(actionEvent, eventType, eventCallbacksWithParam))
					{
						// check for group event callbacks.
						// Group event callbacks are all persistent, since we don't know which event in the group might come in.
						// string eventType = actionEvent.getString("type", "");

						if (eventGroupCallbacks.ContainsKey(eventType))
						{
							EventGroupDelegate callback = eventGroupCallbacks[eventType];
							if (callback != null)
							{
								if (!groupCallbackData.ContainsKey(callback))
								{
									groupCallbackData.Add(callback, new Dictionary<string, JSON>());
								}
								groupCallbackData[callback].Add(eventType, actionEvent);
								checkFastUpdateAction(eventType);
							}
						}
						else if (addToLostAndFound)
						{
							List<JSON> events = null;
							if (!lostAndFoundEvents.TryGetValue(eventType, out events))
							{
								events = new List<JSON>();
								lostAndFoundEvents[eventType] = events;
							}
							events.Add(actionEvent);
						}
					}
				}
			}
		}
		
		// Finally do the group callbacks.
		foreach (KeyValuePair<EventGroupDelegate, Dictionary<string, JSON>> kvp in groupCallbackData)
		{
			kvp.Key(kvp.Value);
		}

	}

	public static string getInfoString()
	{
		if (errorBaseExtraInfo == null)
		{
			return "";
		}
		
		return string.Format(
			errorBaseExtraInfo,
			(int)Time.realtimeSinceStartup,
			GameState.currentStateName
		);
	}

	/// Logs an error on the server, returns true on success and false on failure.
	public static bool sendLogError(string message, string stackTrace = null)
	{
		return sendLogErrorInternal(message, "error", stackTrace);
	}

	public static bool sendLogWarning(string message, string stackTrace = null)
	{
		return sendLogErrorInternal(message, "warning", stackTrace);
	}

	private static bool sendLogErrorInternal(string message, string severity, string stackTrace)
	{		
		// Build up the error information:
		string errorString = string.Format(errorBaseCompiled, JSON.sanitizeString(message),
			JSON.sanitizeString(stackTrace), JSON.sanitizeString(getInfoString()));

		if (string.IsNullOrEmpty(Glb.logErrorUrl))
		{
			if (Application.isEditor)
			{
				Debug.LogError("Dropping SPLUNK: " + errorString);
			}
			return false;
		}
		
		if (Application.isEditor && !Data.debugMode)
		{
			// Do not log to splunk if we are in the editor on a non-debug config (i.e. production).
			// Chuck hates unnecessary logs in production.
			Debug.LogError("Faking SPLUNK log error: " + errorString);
			return true;
		}

		if (Application.isEditor)
		{
			Debug.Log("SPLUNK>>: " + errorString);
		}

		// Build the POST form
		Dictionary<string,string> elements = new Dictionary<string,string>();

		elements.Add("error", errorString);
		elements.Add("priority", severity);

		// Player is null if this happens before player is set or right after a reset
		if (SlotsPlayer.instance != null && SlotsPlayer.instance.socialMember != null)
		{
			elements.Add("sc_id", SlotsPlayer.instance.socialMember.zId);
		}

		WWW www = getRequestWWW(Glb.logErrorUrl, elements);
		rememberOrphanWWW(www);

		return true;
	}

	// Sends a splunk "Log" event (actually queues it up to be sent as a batch)
	//
	// Main message can only be 128 characters in length (server will truncate anything larger)
	// Supports an optional set of user fields (up to 30, if more will be split into multiple events)
	public static bool sendLogInfo(string name, string message, Dictionary<string,string> fields = null, bool forceFlush = false)
	{
		if (string.IsNullOrEmpty(Glb.logEventUrl))
		{
			return false;
		}
		
		if (Application.isEditor && !Data.debugMode)
		{
			// Do not log to splunk if we are in the editor on a non-debug config (i.e. production).
			// Chuck hates unnecessary logs in production.
			Debug.Log("Faking splunk log event: " + name + "\n" + message);
			return true;
		}
		
		// Check if this log should be sampled or skipped
		if (Data.liveData != null)
		{
			string key = "LOG_CLIENT_RATE_" + CommonText.makeIdentifier(name).ToUpper();
			int sampleRate = Data.liveData.hasKey(key) ? Data.liveData.getInt(key, Glb.SERVER_LOG_SAMPLE_RANGE) : Glb.SERVER_LOG_SAMPLE_RANGE;
			
			if (sampleRate < Glb.SERVER_LOG_SAMPLE_RANGE &&
				Random.Range(0, Glb.SERVER_LOG_SAMPLE_RANGE) > sampleRate)
			{
				// This log event is ignored for splunk logging because
				// a random number is larger than the sampleRate value.
				return false;
			}
		}

		// Start with (optional) user-provided fields
		if (fields==null) { fields = new Dictionary<string,string>(); }

		// Add extra fields
		fields["message"] = message;
		fields["version"] = Glb.clientVersion;
		fields["elapsed"] = Time.realtimeSinceStartup.ToString();
		fields["gamestate"] = GameState.currentStateName;

		// Server accepts a max # of fields per event, so split into batches if we need to
		List<Dictionary<string,string>> fieldGroups = null;
		if(fields.Count <= MAX_SPLUNK_LOG_FIELDS)
		{
			// Fields fit into one event
			fieldGroups = new List<Dictionary<string,string>>(1);
			fieldGroups.Add( fields );
		}
		else
		{
			// Too many fields, must split (-2 so we can add 2 fields to each batch below)
			fieldGroups = splitDictionary(fields, MAX_SPLUNK_LOG_FIELDS - 2);

			// When we split, we add a "joinkey" to each batch to rejoin them in splunk
			string joinKey = Zynga.Core.Platform.DeviceInfo.DeviceUniqueIdentifier + "_" + Random.Range(0, int.MaxValue);
			foreach (Dictionary<string,string> fieldGroup in fieldGroups)
			{
				fieldGroup["message"] = message;
				fieldGroup["joinkey"] = joinKey;
			}
		}

		// Create a splunk event for each group we have, queue for batching
		foreach(var fieldGroup in fieldGroups)
		{
			Dictionary<string,object> splunkEvent = new Dictionary<string,object>();
			splunkEvent["type"] = "MobileClient";
			splunkEvent["name"] = name;
			splunkEvent["fields"] = fieldGroup;
			splunkEventQueue.Add( splunkEvent );
		}

		// reset splunk batch timer
		splunkEventTimer.startTimer( MAX_SPLUNK_IDLE_IN_SEC );

		// flush if we need to
		handlePendingSplunkEvents(forceFlush);

		return true;
	}

	private static void postAndFlushLogInfo()
	{
		if (splunkEventQueue.Count == 0) { return; }

		// Build the POST form
		Dictionary<string,string> elements = new Dictionary<string,string>();
		elements.Add("batch", JSON.createJsonString(null, splunkEventQueue));
		elements.Add("client_id", (int)StatsManager.ClientID + "");

		// Player is null if this happens before player is set or right after a reset
		if (SlotsPlayer.instance != null && SlotsPlayer.instance.socialMember != null)
		{
			elements.Add("sc_id", SlotsPlayer.instance.socialMember.zId);
		}

		WWW www = getRequestWWW(Glb.logEventUrl, elements);
		rememberOrphanWWW(www);

		// empty the queue
		splunkEventQueue.Clear();
	}

	// Must be called periodically to flush any queued splunk events as needed
	public static void handlePendingSplunkEvents(bool shouldFlush = false)
	{
		if (splunkEventQueue.Count > 0)
		{
			if (splunkEventTimer.isExpired || 
				splunkEventQueue.Count >= MAX_SPLUNK_QUEUE_SIZE)
			{
				shouldFlush = true;
			}

			if (shouldFlush)
			{
				postAndFlushLogInfo();
			}
		}
	}

	// Splits a dictionary into multiple dictionaries with a maximum number of elements each.
	// Returns a list of (0 or more) size-constrained dictionaries.
	private static List<Dictionary<string,string>> splitDictionary(Dictionary<string,string> original, int maxSize)
	{
		List<Dictionary<string,string>> list = new List<Dictionary<string,string>>();
		Dictionary<string,string> newDict = null;

		foreach (KeyValuePair<string,string> entry in original)
		{
			if (newDict == null || newDict.Count >= maxSize)
			{
				newDict = new Dictionary<string,string>(maxSize, original.Comparer);
				list.Add(newDict);
			}
			newDict.Add(entry.Key, entry.Value);
		}
		return list;
	}
	
	// Used by fire-and-forget WWW calls
	private static void rememberOrphanWWW(WWW www)
	{
		// Make a new list of pending WWWs to prevent premature garbage collection
		List<WWW> newPendingLogWWWs = new List<WWW>();
		
		// Store a reference to the WWW object so that it isn't garbage collected
		newPendingLogWWWs.Add(www);
		
		// Add in any old pending requests that are still active
		foreach (WWW oldWWW in pendingLogWWWs)
		{
			if (oldWWW != null && !oldWWW.isDone)
			{
				newPendingLogWWWs.Add(oldWWW);
			}
		}
		
		// Swap in new pending list
		pendingLogWWWs.Clear();
		pendingLogWWWs = newPendingLogWWWs;
	}

	/// Sets up some error strings early so that they can be used with less extra memory overhead later.
	/// This is important because out-of-memory errors are common and we don't want to lose them.
	/// This function should only be called once, after we have the fbId and scId from LoadPlayerData.
	public static void makeErrorBaseStrings()
	{
		System.Text.StringBuilder errorBaseExtraInfoStr = new System.Text.StringBuilder(512);

		errorBaseExtraInfoStr.AppendFormat(" version={0}", Glb.clientVersion);
		errorBaseExtraInfoStr.AppendFormat(" data=", LoadGlobalData.getGlobalDataVersion());
		
		errorBaseExtraInfoStr.Append(" elapsed={0}");       // getInfoString() fills this in
		errorBaseExtraInfoStr.Append(" gamestate={1}");     // getInfoString() fills this in
		
		errorBaseExtraInfoStr.AppendFormat(" platform={0}", Application.platform.ToString());
		errorBaseExtraInfoStr.AppendFormat(" os={0}", SystemInfo.operatingSystem.Replace(" ", "_"));
		errorBaseExtraInfoStr.AppendFormat(" model={0}", SystemInfo.deviceModel.Replace(" ", "_"));
		errorBaseExtraInfoStr.AppendFormat(" device={0}", SystemInfo.deviceName.Replace(" ", "_"));
		errorBaseExtraInfoStr.AppendFormat(" ram={0}", SystemInfo.systemMemorySize);
		errorBaseExtraInfoStr.AppendFormat(" vram={0}", SystemInfo.graphicsMemorySize);
		
		errorBaseExtraInfoStr.AppendFormat(" abilities={0}-{1}-{2}-{3}-{4}-{5}-{6}", SystemInfo.processorCount, 
			SystemInfo.graphicsDeviceID, SystemInfo.graphicsShaderLevel,
			SystemInfo.supportedRenderTargetCount, true, 
			SystemInfo.supportsImageEffects, SystemInfo.supportsShadows);
		errorBaseExtraInfoStr.AppendFormat(" language={0} ",Localize.language);
		
		// SO MANY Identities to enumerate:
		if ((SlotsPlayer.instance != null) && (SlotsPlayer.instance.socialMember != null))
		{
			errorBaseExtraInfoStr.AppendFormat(" Ident_Player={0}_{1}",SlotsPlayer.instance.socialMember.id, SlotsPlayer.instance.socialMember.zId);
		}
		if ((ZdkManager.Instance != null) && (ZdkManager.Instance.Zsession != null))
		{
			errorBaseExtraInfoStr.AppendFormat(" Ident_ZDK={0}_{1}", ZdkManager.Instance.Zsession.Snid, ZdkManager.Instance.Zsession.Zid);
		}

		/*if (Packages.SocialAuthAnonymous != null && Packages.SocialAuthAnonymous.Channel != null && Packages.SocialAuthAnonymous.Channel.Session != null)
		{
			errorBaseExtraInfoStr.AppendFormat(" Ident_Anon={0}_{1}", Snid.Anonymous,
				Packages.SocialAuthAnonymous.Channel.Session.Zid);
		}*/

		errorBaseExtraInfo = errorBaseExtraInfoStr.ToString();
	}

	/// Delegate for the "game_reset" event.
	public static void gameResetEvent(JSON data)
	{
		forceGameRefresh("game_reset event", "actions_error_message", false);
	}

	/// Halt the scene, shit just got serious.
	/// Since the game needs to be refreshed, we stop processing most scripts while
	/// waiting for the player to acknowledge that the game needs to be refreshed.
	public static void forceGameRefresh(string debugMessage, string userMessageKey, bool reportError = true, bool doLocalization = true)
	{
		if (reportError)
		{
			if (debugMessage != "")
			{
				debugMessage = "\n\n" + debugMessage;
				if (Data.debugMode)
				{
					Bugsnag.LeaveBreadcrumb("Game reload forced, debug message is : " + debugMessage);
				}
			}
			
			// Send the error server the message (hopefully the server already has a related error logged so that we can track it)
			sendLogError(debugMessage, "Server.forceGameRefresh()");
		}

		Server.unregisterEventDelegate("slots_outcome");

		// It's entirely possible don't have localizations yet.
		// Check to see if those exist before we attempt to use them:
		string titleKey = "alert";
		string textKey;
		if (userMessageKey == "" || (doLocalization && !Localize.keyExists(userMessageKey)))
		{
			textKey = "actions_error_message";
		}
		else
		{
			textKey = userMessageKey;
		}
		
		if (Localize.keyExists(titleKey))
		{
			titleKey = Localize.text(titleKey);
		}
		else
		{
			titleKey = "Connection Error!";
		}
		
		if (doLocalization)
		{
			if (Localize.keyExists(textKey))
			{
				textKey = Localize.text(textKey);
			}
			else
			{
				textKey = string.Format(
					"Could not connect to {0}, please check your connection.\n\nReset Error: {1}",
					Localize.getGameName(), string.IsNullOrEmpty(debugMessage) ? recentErrorMessage : debugMessage
					);
			}
		}
		
		// If we aren't running a production build, then append the server message to the dialog.
		if (Data.debugMode && !string.IsNullOrEmpty(recentServerErrorMessage))
		{
			textKey += "\n\n" + recentServerErrorMessage;
			recentServerErrorMessage = "";
		}
		
		PreferencesBase prefs = SlotsPlayer.getPreferences();
		prefs.SetString(Prefs.AUTO_LOAD_GAME_KEY, ""); //Setting this to a blank string to force us to load back into the lobby after the refresh
		prefs.Save();
		GenericDialog.showDialog(
			Dict.create(
				D.TITLE, titleKey,
				D.MESSAGE, textKey,
				D.REASON, "force-game-refresh",
				D.CALLBACK, new DialogBase.AnswerDelegate( (args) => { Glb.resetGame("forced game refresh: " + debugMessage); } )
			),
			SchedulerPriority.PriorityType.MAINTENANCE
		);

		// Adding this because you should always be able to click the ok button.
		// Some server errors can lead to a bad time with mouse input.
		NGUIExt.enableAllMouseInput();
		
		// Disable action batches until the reload.
		ServerAction.enableCommunication = false;
	}
	
	public static void connectionCriticalFailure(string errorOrigin, string errorMessage)
	{
		Debug.LogErrorFormat("Critical connection failure: ({0})", errorOrigin);
		
		// Hide the loading screen so we can show an error dialog.
		Loading.hide (Loading.LoadingTransactionResult.FAIL);
		
		string connectivityMessage = "";
		switch (Application.internetReachability)
		{
			case NetworkReachability.NotReachable:
				connectivityMessage = "Cannot detect any connection.";
				break;
			case NetworkReachability.ReachableViaCarrierDataNetwork:
				connectivityMessage = "Please make sure cellular data is enabled for this app.";
				break;
			case NetworkReachability.ReachableViaLocalAreaNetwork:
				connectivityMessage = "Unable to reach game servers.";
				break;
		}
		
		GenericDialog.showDialog(
			Dict.create(
				D.TITLE, "Check Connection",
				D.MESSAGE, string.Format(
					"Could not connect to {0}, please check your connection. {1}\n\n{2} Error: {3}",
					Localize.getGameName(), connectivityMessage, errorOrigin, errorMessage
				),
				D.REASON, "server-connection-issue",
				D.CALLBACK, new DialogBase.AnswerDelegate(
					(args) =>
						{
							Glb.resetGame(string.Format("{0} Error: {1}", errorOrigin, errorMessage));
						})
				),
				SchedulerPriority.PriorityType.IMMEDIATE
			);
	}

	/// Implements IResetGame
	public static void resetStaticClassData()
	{
		waitingForActionsResponse = false;
		pendingResponseTimer = new GameTimer(RESPONSE_TIMEOUT_INTERVAL);
		pendingLogWWWs = new List<WWW>();
		actionEvents = new List<JSON>();
		lostAndFoundEvents.Clear();
#if !ZYNGA_PRODUCTION
		readFakeMessageQueue(true);
#endif
		multipleEvents = new List<JSON>();
		responses = new Dictionary<string, JSON>();
		accessKey = "";
		shouldHaveCredits = -1L;
		recentHttpErrorMessage = "";
		recentServerErrorMessage = "";
		resetEventCallbacks();
	}

	// Ensure that the event callbacks are cleaned out when the game resets,
	// since the game sets them up again on a reload
	private static void resetEventCallbacks()
	{
		eventCallbacksOneShot.Clear();
		eventCallbacksPersistent.Clear();
		eventGroupCallbacks.Clear();
	}

	public static void collectDailyBonus(JSON data)
	{
		if (DailyBonusButton.instance != null)
		{
			CollectBonusDialog.showDialog(data);
			UAWrapper.Instance.OnCollectDailyBonus();
		}
	}   

	public static void processTimerOutcome(JSON data)
	{
		Decs.completeEvent("timer_outcome", false);

		UAWrapper.Instance.OnCollectDailyBonus();

		//Check for the experient here to decide what wheel dialog to pop
		int payoutID = data.getInt("payout_id", -1);

		if (payoutID != -1)
		{
			if (data.hasKey("outcomes"))
			{
				if (ExperimentWrapper.NewDailyBonus.isInExperiment)
				{					
					DailyBonusGameTimer.refreshData(data);
					TimedBonusFeature feature = new TimedBonusFeature(data);
					DailyBonusButtonHIRV3 buttonV3 = DailyBonusButton.instance as DailyBonusButtonHIRV3;
					bool isPetCollect = data.getBool("virtual_pet_collect", false);
					if (buttonV3 != null && buttonV3.petOverlay != null && isPetCollect)
					{
						VirtualPetsFeature.instance.onPetCollect();
						if (SlotsPlayer.instance != null && SlotsPlayer.instance.dailyBonusTimer != null)
						{
							SlotsPlayer.instance.dailyBonusTimer.startTimer(feature.nextCollectDateTime);	
						}	
						buttonV3.petOverlay.onBonusDataRecieved(feature);
					}
					else
					{
						NewDailyBonusDialog.showDialog(feature);
						
						//if the user attempted a pet collect but the server did not allow it, update the visibility of the icon
						if (buttonV3 != null)
						{
							buttonV3.checkForPetCollect();
						}
					}
				}
			}
		}
	}

	public static void storePendingBonusSummaryID(JSON data)
	{
		string eventName = data.getString ("event", "");
		int gameNum = data.getInt("game", 0);
		ChallengeGamePresenter.AddBonusEventIdentifier (eventName, gameNum);
		Bugsnag.LeaveBreadcrumb("Storing pending bonus summary ID: " + eventName);
	}

	// Register persistent event delegates.
	public static void registerEventDelegates()
	{
		Server.registerEventDelegate("game_reset", gameResetEvent, true);
		Server.registerEventDelegate("timer_outcome", processTimerOutcome, true);
		Server.registerEventDelegate("collect_bonus", collectDailyBonus, true);
		Server.registerEventDelegate("pending_bonus_summary_id", storePendingBonusSummaryID, true);
		Server.registerEventDelegate("show_missed_bonus_summary", BonusGameErrorDialog.handlePresentation, true);
		Server.registerEventDelegate("royal_rush_complete", RoyalRushEvent.instance.onCompleteRoyalRushEvent, true);
		Server.registerEventDelegate(WeeklyRaceDirector.COMPLETE_EVENT, WeeklyRaceDirector.onWeeklyRaceComplete, true);
		Server.registerEventDelegate(WeeklyRaceDirector.CREDITS_EVENT, WeeklyRaceDirector.onClaimReward, true);
		Server.registerEventDelegate(LottoBlastMinigameDialog.PURCHASE_EVENT, LottoBlastMinigameDialog.onPaymentConfirmed, true);
		PartnerPowerupCampaign.registerStaticEventDelegates();
	}

	/// Register a callback function to be called when the specified event is received.
	/// Registrations are cleared when the event is received, so event registration
	/// is required every time an event is expected to be received.
	public static void registerEventDelegate(string eventKey, EventDelegate callback, bool isPersistent = false)
	{
		JSON data = null;
		if(responses != null)
		{
			if (responses.TryGetValue(eventKey, out data))
			{
				callback(data);
				if (!isPersistent)
				{
					Debug.LogWarning("Non Persistant Event Data Receieved Prematurally");
					return;
				}
			}
		}

		if (isPersistent && !string.IsNullOrEmpty(eventKey))
		{
			//check for events in lost and found
			if (lostAndFoundEvents.TryGetValue(eventKey, out List<JSON> events))
			{
				RoutineRunner.instance.StartCoroutine(runCallbackNextFrame(callback, events));
				lostAndFoundEvents.Remove(eventKey);
			}
		}

		
		Dictionary<string, EventDelegate> d = isPersistent ? eventCallbacksPersistent : eventCallbacksOneShot;

		if (d.ContainsKey(eventKey))
		{
			d[eventKey] += callback;
		}
		else
		{
			d[eventKey] = callback;
		}

	}

	private static IEnumerator runCallbackNextFrame(EventDelegate callback, List<JSON> events)
	{
		yield return new WaitForEndOfFrame();
		yield return null;
		
		
		foreach (JSON eventData in events)
		{
			if (eventData == null)
			{
				continue;
			}
			callback(eventData);	
		}
	}
	
	/// Register a callback function with 1 System.Object parameter to be called when the specified event is received.
	/// Registrations are cleared when the event is received, so event registration
	/// is required every time an event is expected to be received.
	public static void registerEventDelegate(string eventKey, EventDelegateWithParam callback, object callbackParameter, bool isPersistent=false)
	{
		JSON data = null;
		if(responses != null)
		{
			if (responses.TryGetValue(eventKey, out data))
			{
				callback(data, callbackParameter);
				if (!isPersistent)
				{
					Debug.LogWarning("Non Persistant Event Data Receieved Prematurally");
					return;
				}
			}
		}
		
		EventCallbackData callbackData;
		if (eventCallbacksWithParam.TryGetValue(eventKey, out callbackData))
		{
			// Note: overwrites any existing settings for eventKey
			callbackData.callback = callback;
			callbackData.callbackParameter = callbackParameter;
			callbackData.isPersistent = isPersistent;
			eventCallbacksWithParam[eventKey] = callbackData;	// I think this is unnecessary, but just in case...
		}
		else
		{
			callbackData = new EventCallbackData();
			callbackData.callback = callback;
			callbackData.callbackParameter = callbackParameter;
			callbackData.isPersistent = isPersistent;
			eventCallbacksWithParam[eventKey] = callbackData;
		}

	}
	
	// Register a group callback instead of individual event callbacks,
	// Group callbacks gets called ONCE per batch, if any event in that batch is registered for the callback.
	// All data for all events are passed to the single callback in a dictionary,
	// for the callback to sort out how to deal with it in any order it wants.
	public static void registerEventGroupDelegate(string[] eventKeys, EventGroupDelegate callback)
	{
		// The event queue is not supported for this kind of Delegate since its only used once in race to riches
		// We should change the way we handle this group event to using a more generic and scalable approach
		foreach (string key in eventKeys)
		{
			eventGroupCallbacks[key] = callback;
		}
	}
	
	/// Un-Register a callback function to be called when the specified event is received.
	public static void unregisterEventDelegate(string eventKey, EventDelegate callback, bool isPersistent = false)
	{
		Dictionary<string, EventDelegate> d = isPersistent ? eventCallbacksPersistent : eventCallbacksOneShot;
		
		if (d.ContainsKey(eventKey))
		{
			d[eventKey] -= callback;
		}
	}
	
	public static void onTimeout()
	{
		pendingResponseTimer = new GameTimer(RESPONSE_TIMEOUT_INTERVAL);
		#if !ZYNGA_PRODUCTION
		string errorMessage = "Response Timeout for " + responses.Count + " entries: /n";
		foreach(KeyValuePair<string, JSON> entry in responses)
		{
			errorMessage += "	response: " + entry.Key + "/n";
		}
		Debug.LogError(errorMessage);
		#endif
	}

	
	/// Un-Register a callback function to be called when the specified event is received.
	public static void unregisterEventDelegate(string eventKey, bool isPersistent = false)
	{
		// Note: ContainsKey is redundant, Remove will not throw exception if key not found, and it returns true
		//       if item was removed.  so this fn could be changed to be more efficient, but it's rarely called
		//       so I wont bother.
		if (!eventCallbacksWithParam.ContainsKey(eventKey))
		{
			if (isPersistent)
			{
				eventCallbacksPersistent.Remove(eventKey);
			}
			else
			{
				eventCallbacksOneShot.Remove(eventKey);
			}
		}
		else
		{
			eventCallbacksWithParam.Remove(eventKey);
		}
	}

	/// Checks the callbacks for the event type and calls the handler, then optionally unregisters the event.
	private static bool checkEventCallbacks(JSON actionEvent, string eventType, Dictionary<string, EventDelegate> eventCallbacks, bool doUnregister)
	{
		checkFastUpdateAction(eventType);

		if (eventCallbacks.ContainsKey(eventType) && eventCallbacks[eventType] != null)
		{
			eventCallbacks[eventType](actionEvent);

			if (doUnregister)
			{
				eventCallbacks.Remove(eventType);
			}

			return true;
		}
		
		return false;
	}

	// version of checkEventCallbacks that works with callbacks that take 1 param
	private static bool checkEventCallbacks(JSON actionEvent, string eventType, Dictionary<string, EventCallbackData> eventCallbacks)
	{
		checkFastUpdateAction(eventType);

		EventCallbackData callbackData;
		if (eventCallbacks.TryGetValue(eventType, out callbackData) && callbackData != null)
		{
			callbackData.callback(actionEvent, callbackData.callbackParameter);

			if (!callbackData.isPersistent)	
			{
				eventCallbacks.Remove(eventType);  // gonna actually do the removal, unlike the original version of this fn above
			}
			return true;
		}
		return false;
	}

	private static void checkFastUpdateAction(string eventType)
	{
		// Clear the fast polling status if this event type is what we were polling for
		if (ServerAction.fastUpdateActionEventType == eventType)
		{
			ServerAction.clearFastUpdateMode();
		}
	}
	
	// Adjusts the last known credits amount from the server.
	// Sometimes we need to do this when credits are added to the client
	// and we start another spin before receiving the response to the claim action.
	// Starting a spin validates the client credits amount, which
	// will be different from the new client amount unless we adjust this.
	// Without this, we get a client-side credits desync on the next spin.
	public static void adjustKnownCredits(long amount)
	{
		if (shouldHaveCredits == -1)
		{
			// If the player has never spun in this session, then don't adjust it.
			return;
		}
		
		if (amount < 1)
		{
			Debug.LogError("Server.adjustKnownCredits was passed " + amount + " credits. This should only be called with a positive value.");
			return;
		}
		
		shouldHaveCredits += amount;
	}

	// used if you have dialogs that don't show up in time to award credits (asset bundle laoding) and auto spin does more spins in the meantime, ticket tumbler uses this
	// shouldHaveCredits will add this value when checking for desyncs
	// Note 8/24/2020:
	// Broke adjustPendingCredits() into two funcs - handlePendingCreditsCreated and handlePendingCreditsSurfaced
	// Investigation Note 7/2020:
	// adjustPendingCredits() is the only place that totalPendingCredits and pendingCreditsDict get modified (besides being reset).
	// Only 4 places call adjustPendingCredits(), 3 are related to race to riches and pass source as "race_to_riches_{theme}"
	// The only other place that calls this is addFeatureCredits() after it has called SlotsPlayer.addCredits(). 
	// That appears to only ever be called with a positive amount, however it then calls this function with -amount.
	// Since none of those sources ever call this with a positive amount for their source first, they will always
	// be creating entries in pendingCreditsDict with a negative amount and deducting the amount from totalPendingCredits
	// which can potentially cause it to go negative.
	public static void handlePendingCreditsCreated(string source, long amount = 0)
	{
		if (amount < 0)
		{
			sendLogInfo("credit_change_error", 
				"handlePendingCreditsCreated() received a negative amount", 
				new Dictionary<string, string>
				{
					{"amount", amount.ToString()},
					{"source", source}
				});
				
			return;
		}
		
		long existingPendingAmount;
		pendingCreditsDict.TryGetValue(source, out existingPendingAmount);
		pendingCreditsDict[source] = existingPendingAmount + amount;

		sendLogInfo("credit_change", 
			"handlePendingCreditsCreated() recorded pending credits for source", 
			new Dictionary<string, string>
			{
				{"amount", amount.ToString()},
				{"previousBalance", existingPendingAmount.ToString()},
				{"sourceBalance", pendingCreditsDict[source].ToString()},
				{"totalPendingCredits", totalPendingCredits.ToString()},
				{"source", source}
			});
	}
	public static void handlePendingCreditsSurfaced(string source, long amount = 0)
	{
		bool isExistingSource = pendingCreditsDict.ContainsKey(source);
		if (!isExistingSource)
		{
			sendLogInfo("credit_change_error", 
				"handlePendingCreditsSurfaced() has no pending credits for source", 
				new Dictionary<string, string>
				{
					{"amount", amount.ToString()},
					{"totalPendingCredits", totalPendingCredits.ToString()},
					{"source", source}
				});
			
			Debug.LogError($"handlePendingCreditsSurfaced() has no pending credits for source={source} amount={amount}");
			
			return;
		}

		long existingPendingAmount = pendingCreditsDict[source];
		pendingCreditsDict[source] -= amount;

		sendLogInfo("credit_change", 
			"handlePendingCreditsCreated() surfaced pending credits to user", 
			new Dictionary<string, string>
			{
				{"amount", amount.ToString()},
				{"previousBalance", existingPendingAmount.ToString()},
				{"sourceBalance", pendingCreditsDict[source].ToString()},
				{"totalPendingCredits", totalPendingCredits.ToString()},
				{"source", source}
			});
		
		if (pendingCreditsDict[source] == 0)
		{
			pendingCreditsDict.Remove(source);
			return;
		}
		
		if (pendingCreditsDict[source] < 0)
		{
			sendLogInfo("credit_change_error", 
				"handlePendingCreditsSurfaced() has negative pending balance after crediting", 
				new Dictionary<string, string>
				{
					{"amount", amount.ToString()},
					{"sourceBalance", pendingCreditsDict[source].ToString()},
					{"totalPendingCredits", totalPendingCredits.ToString()},
					{"source", source}
				});
			
			Debug.LogError($"handlePendingCreditsSurfaced() has negative pending balance after crediting source={source} amount={amount} sourceBalance={pendingCreditsDict[source]}");
			
			pendingCreditsDict.Remove(source);
			return;
		}
		
		if (pendingCreditsDict[source] > 0)
		{
			sendLogInfo("credit_change_error", 
				"handlePendingCreditsSurfaced() has remaining pending balance after crediting", 
				new Dictionary<string, string>
				{
					{"amount", amount.ToString()},
					{"sourceBalance", pendingCreditsDict[source].ToString()},
					{"totalPendingCredits", totalPendingCredits.ToString()},
					{"source", source}
				});
			
			Debug.LogError($"handlePendingCreditsSurfaced() has remaining pending balance after crediting source={source} amount={amount} sourceBalance={pendingCreditsDict[source]}");
		}
	}
	public static bool hasPendingCredits(string source)
	{
		return pendingCreditsDict.ContainsKey(source);
	}

	public static void removePendingCredits(string source)
	{
		if (!pendingCreditsDict.ContainsKey(source))
		{
			sendLogInfo("credit_change_error", 
				"removePendingCredits() tried to surface pending credits from a nonexistent source", 
				new Dictionary<string, string>
				{
					{"totalPendingCredits", totalPendingCredits.ToString()},
					{"source", source}
				});
			
			return;
		}
		
		handlePendingCreditsSurfaced(source, pendingCreditsDict[source]);
	}

	// Nukes all of the credits
	public static void resetPendingCredits()
	{
		pendingCreditsDict.Clear();
	}

}

/// Enum for the speed quality of the user's internet connection
public enum ConnectionLevel
{
	UNKNOWN,
	SLOW,
	AVERAGE,
	FAST
}

public delegate void EventDelegate(JSON data);
public delegate void EventDelegateWithParam(JSON data, System.Object param);
public delegate void EventGroupDelegate(Dictionary<string, JSON> data);